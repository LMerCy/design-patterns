## meta programming

### template

类型推断
模板参数不允许自动类型转换，只允许deduce

- 单一类型
    - 调用参数是引用传递，必须是相同类型
    - 调用参数是按值传递，需要是满足简单退化的条件
- 多个类型的返回参数问题
    - 实例化过程中给定返回参数
    - 将返回类型放在第一个，然后指定第一个类型。输入是根据实际给定的实参推断出来。
    - auto
    - 使用decltype和decay来解决。
    - common type

### 分支代码
- std::conditionnal std::conditional_t
- 部分特化，注意在未完全特化的类模板中，不能存在完全特化的函数，可以给此类函数加一个假的类型不做特化，实现部分特化。
- std::enable_if std::enable_if_t， 该接口可以在函数参数类型一致的情况下实现重载，写法也比较固定，主要机制是SFINAE.(很想c里面的#define)
- c++17引入的if constexpr，该接口可以让编译器分支代码的可读性更高，和运行期非常接近。同时可以让编译器的实例数量更少。缺点是1.容易忘记写，但是编译器不会报错，代码就变成了运行时判断。2.使用面较窄，一般在函数内部用来选择代码，但是无法通过该接口让不同的分支返回不同的类型作为结果。

### 循环

元编程中一般通过递归去实现循环。