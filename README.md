# design-patterns
design patterns with c++

c++ version of head first design patterns

thanks to https://refactoringguru.cn/design-patterns

## 策略模式

策略模式是在算法库中很常见的一种模式，主要是通过定义一簇算法，让他们之间可以互相替换，而且不会影响到客户使用，同时用户可以在使用过程中动态地去改变所使用的具体算法。所以在书中提供的Duck类中，真正体现策略模式的是Quack和Fly两个接口类,Duck可以通过setFly和setQuack方法动态的去改变具体是哪种飞行和叫的方式。同时Duck是通过一个具体的函数来调用各类算法的调用，当然前提就是这类算法的调用都继承了同一个方法（本质上是一种多态）。

## 简单工厂

简单工厂并不是一个设计模式，他是一种生成对象的方式，和策略模式看上去很类似，但是本质上差别很大，简单工厂如前所说是生成对象的，而策略模式是通过重写父类的方法来实现方法的动态替换，所以两者其实是可以结合使用的。首先通过简单工厂来创建对象，其次在通过策略模式来使用不同对象的算法。

## 工厂方法模式

网上有很多介绍工厂方法模式的文章，大部分都是和各种生成实践联系在一起，但是个人看完之后大多似懂非懂，直到看到winter在知乎的回答才比较清楚：[工厂模式（factory  Method）的本质是什么？为什么引入工厂模式？](https://www.zhihu.com/question/42975862/answer/1244807350)

一句话概括的话就是，外面想要新建一个对象，但是不知道对象的具体类型，同时由于多态的存在，我们可以是用这些对象的共同的父类的某些方法。

问题是我们为什么不能直接调用具体对象的构造函数，同时复用这些对象的某些方法呢？如：./Creational/why_need_factory.cpp

## 单例模式

单例模式看上去简单，但是实现起来很复杂，尤其是想写一个可以被继承的单例模式，具体可以参考：https://www.cnblogs.com/loveis715/archive/2012/07/18/2598409.html

## 模板方法

策略模式是定义了一族算法，客户可以轻易地替换算法。模板方法则定义了一个算法大纲，而由子类定义其中某些步骤的方法。

# 原则

## 依赖倒置原则

不能让高层组件依赖低层组件，而且，不管高层组件和低层组件，“两者”都应该依赖于抽象。

在Factory代码中，PizzaStore是高层组件，而Pizza的实现是低层组件。

## 最少知识原则

减少对象之间的交互，只留下几个“密友”。 

如果某对象是调用其他方法放回的结果，不要调用改对象的方法。这个原则对于新手来说很容易被忽视，但是如果有需要的话，怎么处理呢？需要隐藏该返回的类，比如 A a = b.get(); ret = a.get_temp(), 应该在b中添加方法，改成b.get_temp();

具体来说可以被调用以下范围的类的方法：

- 改对象本身
- 被当做方法的参数而传进来的对象
- 此方法索创建或实例化的任何对象
- 对象的任何组件

## 好莱坞原则

允许低层组件将自己挂钩到系统上，但是要让高层组件决定什么时候和怎么使用底层组件。这条原则并不违反依赖倒置原则，依赖倒置原则的目的在于避免过多依赖，而好莱坞原则可以让低层组件能够被挂钩进高层组件计算中。

